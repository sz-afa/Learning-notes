

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [简介](#简介)
- [select](#select)
  - [头文件](#头文件)
  - [结构体](#结构体)
    - [fd_set](#fd_set)
  - [函数](#函数)
    - [1.FD_ZERO()](#1fd_zero)
    - [2.FD_SET()](#2fd_set)
    - [3.select()](#3select)
    - [4.FD_ISSET()](#4fd_isset)
    - [5.FD_CLR()](#5fd_clr)
  - [总结](#总结)
    - [缺点](#缺点)
- [poll](#poll)
- [epoll](#epoll)

<!-- /code_chunk_output -->
# 简介
select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
`但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的`
而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
# select
## 头文件
```c
/* According to POSIX.1-2001, POSIX.1-2008 */
#include <sys/select.h>

/* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
```
## 结构体
### fd_set
文件描述符集合
## 函数
### 1.FD_ZERO()
```c
//源码
void FD_ZERO(fd_set *set);

//案例
FD_ZERO(&fd_et);        //初始化fd_set
```
### 2.FD_SET()
```c
//源码
void FD_SET(int fd, fd_set *set);

//案例
FD_SET(fd,&my_fd_set);  //将文件描述符fd添加进指定fd_set
```
### 3.select()
```c
//源码
int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

//案例
select(maxfd+1,&my_fd_set,NULL,NULL,NULL);
```
### 4.FD_ISSET()
```c
//源码
int  FD_ISSET(int fd, fd_set *set);
//判断文件描述符集合的就绪文件描述符是否等于文件描述符fd。等于返回1

//案例
if(FD_ISSET(fd, &my_fd_set)){
    //do...
}   
```
### 5.FD_CLR()
```c
//源码
void FD_CLR(int fd, fd_set *set);
//将文件描述符fd 从 set中移除
```
## 总结
一般可以与单向链表结合
```c
tmp = head->next;
while(tmp!=NULL)
{
    FD_SET(tmp->fd,&loginSet);
    tmp = tmp->next;
}
```
### 缺点
- 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
- 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
- select支持的文件描述符数量太小了，默认是1024(可以修改)
# poll
# epoll